<!doctype html>
<html lang="en">
<!--
// TODO: http://cesiumjs.org/Cesium/Apps/Sandcastle/gallery/Geometry%20and%20Appearances.html
-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <title>GIS Test Page</title>
    <style type="text/css">
      html, body, .map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
            font-family: "Roboto","Helvetica","Arial",sans-serif;
      }

      .ol-mouse-position {
          background: white;
      }

      .ol-popup {
      position: absolute;
      background-color: white;
      -webkit-filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
      filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #cccccc;
      bottom: 12px;
      left: -50px;
      min-width: 280px;
      }
      .ol-popup:after, .ol-popup:before {
      top: 100%;
      border: solid transparent;
      content: " ";
      height: 0;
      width: 0;
      position: absolute;
      pointer-events: none;
      }
      .ol-popup:after {
      border-top-color: white;
      border-width: 10px;
      left: 48px;
      margin-left: -10px;
      }
      .ol-popup:before {
      border-top-color: #cccccc;
      border-width: 11px;
      left: 48px;
      margin-left: -11px;
      }
      .ol-popup-closer {
      text-decoration: none;
      position: absolute;
      top: 2px;
      right: 8px;
      }
      .ol-popup-closer:after {
      content: "✖";
      }
      .popup-scroller {
          max-height: 200px;
          font-size: 9pt;
          overflow: auto;
      }



    </style>
    <script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
    <link rel="stylesheet" href="./v3.15.1-dist/ol.css" type="text/css">
    <script src="./v3.15.1-dist/ol.js" type="text/javascript"></script>
    <link rel="stylesheet" href="ol3-layerswitcher/src/ol3-layerswitcher.css" />
    <script src="ol3-layerswitcher/src/ol3-layerswitcher.js"></script>

    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  </head>

  <!--
  -->
<body>
      <div id="map" class="map"></div>
<div id="popup" class="ol-popup">
  <a href="#" id="popup-closer" class="ol-popup-closer"></a>
  <div id="popup-scroller" class="popup-scroller">
  <div id="popup-content"></div>
  </div>
</div>

      <script type="text/javascript">
        var projection = ol.proj.get('EPSG:3857');
        var projectionExtent = projection.getExtent();

    //////////////////////////////
    // http://openlayers.org/en/master/examples/permalink.html#map=2/-3589838.17/141009.86/0
    //////////////////////////////
    // default zoom, center and rotation
      var zoom = 12;
      var center = [-13606244, 4548015];
      var rotation = 0;
      var active_layers = []

        function showPosition(position) {
            var position_in_3857 = ol.proj.transform([position.coords.longitude, position.coords.latitude], 'EPSG:4326', 'EPSG:3857');
            html5_position = position;
            map.getView().setCenter(position_in_3857);
            shouldUpdate = false;
        }

      if (window.location.hash !== '') {
        // try to restore center, zoom-level and rotation from the URL
        var hash = window.location.hash.replace('#map=', '');
        var parts = hash.split('/');
        if (parts.length === 5) {
          zoom = parseInt(parts[0], 10);
          center = [
            parseFloat(parts[1]),
            parseFloat(parts[2])
          ];
          rotation = parseFloat(parts[3]);
          active_layers = JSON.parse(decodeURI(parts[4]));
          console.log("AL:"+active_layers);
        }
      } else {
       var html5_position;
       if (navigator.geolocation) {
           navigator.geolocation.getCurrentPosition(showPosition);
        } else {
        }
      }

       var layer_json = <%= File.read("#{ENV['PROJECT_DIR']}/templates/layers.json") %>
       var base_layers = layer_json.filter( function(value) { return value.type=='base' });
       var overlay_layers = layer_json.filter( function(value) { return value.type!='base' });

	var local_base_layers = base_layers.map( function(item,index){
	    return new ol.layer.Tile({
	       preload: Infinity,
	       type: 'base',
	       title: item.desc,
               visible: false,
	       source: new ol.source.XYZ({
		       url: '/mapcache/tms/1.0.0/' + item.name + '@g2/{z}/{x}/{-y}.png',
	       }),
	    });
	});
//	local_base_layers[0].setVisible(true);

	    
	var local_overlay_layers = overlay_layers.map( function(item,index){
	    return new ol.layer.Tile({
	       title: item.desc,
               visible: false,
	       source: new ol.source.XYZ({
		       url: '/mapcache/tms/1.0.0/' + item.name + '@g2/{z}/{x}/{-y}.png',
	       }),
	    });
	});



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
/// get more features from csv
/// http://zeroviscosity.com/d3-js-step-by-step/step-4-loading-external-data

// TODO - try atlas vectors to save RAM on webgl browsers
// # http://openlayers.org/en/v3.15.1/examples/symbol-atlas-webgl.html?q=vector
// OR: https://github.com/openlayers/ol3/issues/5054
//     http://openlayers.org/en/v3.14.2/examples/image-vector-layer.html
//
// TODO - try if even more can load with something like this: http://openlayers.org/en/v3.15.1/examples/dynamic-data.html?q=clear+layer
var onerow = ''
var i = 0;
var lpr_features = [];
var lpr_source = new ol.source.Vector({features: lpr_features});
d3.csv('lpr.csv', function(error, dataset) {
    dataset.forEach(function(d) {
        d.lat = +d.lat;
        d.lon = +d.lon;
        if (i > 100000) return;
        onerow=d;
        var d3857 = ol.proj.transform([d.lon,d.lat], 'EPSG:4326', 'EPSG:3857');
        geometry = new ol.geom.Point(d3857);
	feature = new ol.Feature({
		geometry:geometry,
                data:d
        });
        i += 1;
        lpr_features.push(feature);
    });
    lpr_source = new ol.source.Vector({features: lpr_features});
    heatmap.setSource(lpr_source);
    clusters.setSource(new ol.source.Cluster({ distance: 16, source:lpr_source}));
    // atlasvector.changed();
    heatmap.changed();
    map.render();
});



////////////////////////////////////////////////////////////////////////////////
// Heatmap
////////////////////////////////////////////////////////////////////////////////
var heatmap = new ol.layer.Heatmap({
  title: 'Heat Map',
  visible: false,
  source: new ol.source.Vector({features: lpr_features}),
  blur: 10,
  radius: 2
});

heatmap.getSource().on('addfeature', function(event) {
  // 2012_Earthquakes_Mag5.kml stores the magnitude of each earthquake in a
  // standards-violating <magnitude> tag in each Placemark.  We extract it from
  // the Placemark's name instead.
  //  var name = event.feature.get('name');
  //  var magnitude = parseFloat(name.substr(2));
  //  event.feature.set('weight', magnitude - 5);
  event.feature.set('weight', 1);
});

////////////////////////////////////////////////////////////////////////////////
// Clusters
////////////////////////////////////////////////////////////////////////////////

var earthquakeFill = new ol.style.Fill({
  color: 'rgba(255, 255, 0, 0.8)'
});
var earthquakeStroke = new ol.style.Stroke({
  color: 'rgba(255, 0, 0, 0.9)',
  width: 1
});
var textFill = new ol.style.Fill({
  color: '#000'
});
var textStroke = new ol.style.Stroke({
  color: 'rgba(255, 255, 255, 0.6)',
  width: 2
});
var invisibleFill = new ol.style.Fill({
  color: 'rgba(255, 0, 0, 1.00)'
});

function createEarthquakeStyle(feature) {
  var name = feature.get('name');
  return new ol.style.Style({
    geometry: feature.getGeometry(),
    image: new ol.style.RegularShape({
      radius1: 7,
      radius2: 3,
      points: 5,
      angle: Math.PI,
      fill: earthquakeFill,
      stroke: earthquakeStroke
    })
  });
}

function nicecolor(num,maxFeatureCount) {
	var opacity = 0.8;
	if (num >= maxFeatureCount / 2) {
		var brightness = 1 - (2.0 * num / maxFeatureCount - 1.0);
		return [127 + 127 * brightness, 0,  0,opacity];
	} else {
		var brightness = 1 - (num / maxFeatureCount * 2);
		return [255, 255*brightness,  0,opacity];
	}
	// their demo had:
	// [255, 153, 0, Math.min(0.8, 0.4 + (size / maxFeatureCount))]
	if      (num < 3.3)  {return [255,255,  0,opacity];}   // "#ffff00"
	else if (num < 10)   {return [255,191,  0,opacity];}   // "#ffcc00"
	else if (num < 33)   {return [255,127,  0,opacity];}   // "#ff8800"
	else if (num < 100)  {return [255, 63,  0,opacity];}   // "#ff4400"
	else if (num < 333)  {return [255,  0,  0,opacity];}   // "#ff0000"
	else if (num < 1000) {return [191,  0,  0,opacity];}   // "#cc0000"
	else if (num < 3333) {return [ 63,  0,  0,opacity];}   // "#880000"
	else                 {return [255,255,255,opacity];} // "#880000"
}

function clustersize(num) {
    if (num < 2) {return 2;}
    return Math.log(num)/Math.log(2) + 5;
}


var maxFeatureCount;
function calculateClusterInfo(resolution) {
  maxFeatureCount = 0;
  var features = clusters.getSource().getFeatures();
  var feature, radius, color;
  for (var i = features.length - 1; i >= 0; --i) {
    var feature = features[i];
    var origFeatures = feature.get('features');
    maxFeatureCount = Math.max(maxFeatureCount, origFeatures.length)
  }
  for (var i = features.length - 1; i >= 0; --i) {
    feature = features[i];
    var originalFeatures = feature.get('features');
    var extent = ol.extent.createEmpty();
    for (var j = 0, jj = originalFeatures.length; j < jj; ++j) {
      ol.extent.extend(extent, originalFeatures[j].getGeometry().getExtent());
    }
    radius = clustersize(originalFeatures.length);
    feature.set('radius', radius);
    color = nicecolor(originalFeatures.length,maxFeatureCount);
    feature.set('color', color);
  }
}

var currentResolution;
function styleFunction(feature, resolution) {
  if (resolution != currentResolution) {
    calculateClusterInfo(resolution);
    currentResolution = resolution;
  }
  var style;
  var size = feature.get('features').length;
  if (size > 1) {
    style = [new ol.style.Style({
      image: new ol.style.Circle({
        radius: feature.get('radius'),
        fill: new ol.style.Fill({
          color: feature.get('color')
        }),
        stroke: earthquakeStroke
      }),
      text: new ol.style.Text({
        text: size.toString(),
        fill: textFill,
        textAlign: 'center', 
        textBaseline: 'middle',
        offsetY: 1,
        font: 'bold 12px Arial',
        //stroke: textStroke
      })
    })];
  } else {
    var originalFeature = feature.get('features')[0];
    style = [createEarthquakeStyle(originalFeature)];
  }
  return style;
}

function selectStyleFunction(feature, resolution) {
  var styles = [new ol.style.Style({
    image: new ol.style.Circle({
      radius: feature.get('radius'),
      fill: invisibleFill
    })
  })];
  var originalFeatures = feature.get('features');
  var originalFeature;
  for (var i = originalFeatures.length - 1; i >= 0; --i) {
    originalFeature = originalFeatures[i];
    styles.push(createEarthquakeStyle(originalFeature));
  }
  return styles;
}

var clusters = new ol.layer.Vector({
  title: 'Clusters',
  visible: false,
  source: new ol.source.Cluster({
    distance: 18,
    source: new ol.source.Vector({features: lpr_features}),
  }),
  style: styleFunction
});
////////////////////////////////////////////////////////////////////////////////

        // The parallel tile loading test assumes your servers are named something like 'map1.example.com'
	var parallel_server_1 = location.hostname.replace('1','1');
	var parallel_server_2 = location.hostname.replace('1','2');
	var parallel_server_3 = location.hostname.replace('1','3');
	var parallel_server_4 = location.hostname.replace('1','4');

	var external_base_layers = [

	    // http://www.acuriousanimal.com/thebookofopenlayers3/chapter02_04_image_layer.html
	    new ol.layer.Image({
		opacity: 0.75,
  	        type: 'base',
		title: 'test image layer',
                visible: false,
		source: new ol.source.ImageStatic({
		    attributions: [
			new ol.Attribution({
			    html: '&copy; <a href="https://www.lib.utexas.edu/maps/historical/">University of Texas Libraries</a>'
			})
		    ],
		    url: 'https://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
		    imageSize: [691, 541],
		    projection: ol.proj.get('EPSG:3857'), // map.getView().getProjection(),
		    imageExtent: ol.extent.applyTransform([-74.22655, 40.71222, -74.12544, 40.77394], ol.proj.getTransform("EPSG:4326", "EPSG:3857"))
		})
	    }),

	    new ol.layer.Tile({
	       preload: Infinity,
	       type: 'base',
	       title: "test parallel loading",
               visible: false,
	       source: new ol.source.XYZ({
		       urls: [
		             'http://'+parallel_server_1+'/mapcache/tms/1.0.0/black_on_white@g2/{z}/{x}/{-y}.png',
		             'http://'+parallel_server_2+'/mapcache/tms/1.0.0/white_on_black@g2/{z}/{x}/{-y}.png',
		             'http://'+parallel_server_3+'/mapcache/tms/1.0.0/subtlecolor@g2/{z}/{x}/{-y}.png',
  		             'http://'+parallel_server_4+'/mapcache/tms/1.0.0/white_roads@g2/{z}/{x}/{-y}.png'
		            ]
	       }),
	    }),




                    new ol.layer.Tile({
                        title: 'Stamen Watercolor',
                        type: 'base',
                        visible: false,
                        source: new ol.source.Stamen({
                            layer: 'watercolor'
                        })
                    }),
                    new ol.layer.Tile({
                        title: 'OSM',
                        type: 'base',
                        visible: false,
                        source: new ol.source.OSM()
                    }),
	
                    new ol.layer.Tile({
                        title: 'Old OSM Data',
                        visible: false,
                        type: 'base',
                        source: new ol.source.TileWMS({
                            url: 'https://go.leapportal.us/tilecache/tilecache.cgi',
                            params: {'LAYERS': 'subtlecolor2'} //,
                            // serverType: 'geoserver'
                        })
                    }),
		    new ol.layer.Tile({
			preload: Infinity,
			type: 'base',
			title: 'composited wms layer',
			visible: false,
			source: new ol.source.TileWMS({
				url: '/mapcache/',
				params: {
		                    'VERSION': '1.1.1',
		                    'LAYERS': 'subtlecolor,opd_lpr,opd_beats'
                                }
			})
		    }),

                    new ol.layer.Tile({
                        title: 'Satellite',
                        type: 'base',
                        visible: false,
                        source: new ol.source.MapQuest({layer: 'sat'})
                    })
       ];


       var external_overlays = [heatmap,clusters,
		       // Consider:
		       // "tile_map_edge_buffer" "256"  
		       // in the .map file instead of a gutter here.
		       // If we do that, we need to use mode=tile, and send
		       // tile requests instead.
		    new ol.layer.Tile({
			preload: Infinity,
			title: 'Uncached user-generated layers',
			visible: false,
 		        source: new ol.source.TileWMS({
		                gutter: 200,
				url: '/mapserv/user_layers',
				params: {
		                    'VERSION': '1.1.1',
		                    'features': '1,2,3',
		                    'userid': '1',
		                    'session': '1',
		                    'LAYERS': 'default'
                                }
			})
		    }),
                    new ol.layer.Tile({
                        title: 'State Overlay',
                        visible: false,
                        source: new ol.source.TileWMS({
                            url: 'http://demo.opengeo.org/geoserver/wms',
                            params: {'LAYERS': 'ne:ne_10m_admin_1_states_provinces_lines_shp'},
                            serverType: 'geoserver'
                        })
                    })
                ];

        var all_base_layers = local_base_layers.concat(external_base_layers);
        var all_overlay_layers = local_overlay_layers.concat(external_overlays);

        var layers = [
            new ol.layer.Group({
                'title': 'Base maps',
                layers: all_base_layers
            }),
            new ol.layer.Group({
                title: 'Overlays',
                layers: all_overlay_layers
            })
        ];
        
        layers.forEach(function(lg){
            lg.getLayers().forEach(function(l){
                var props = l.getProperties();
                if (active_layers.indexOf(props.title) >= 0) {
                    l.setVisible(true);
                }
            });
          });

        var map = new ol.Map({
          layers: layers,
          target: 'map',
          //  renderer: 'webgl',  faster, but heatmap fails
          view: new ol.View({
	    center: center,
            zoom: zoom,
            rotation: rotation
          })
        });


      var mousePositionControl = new ol.control.MousePosition({
        coordinateFormat: ol.coordinate.createStringXY(4),
        projection: 'EPSG:4326',
        undefinedHTML: '&nbsp;'
      });
      map.addControl(mousePositionControl);



    var layerSwitcher = new ol.control.LayerSwitcher({
        tipLabel: 'Légende' // Optional label for button
    });
    map.addControl(layerSwitcher);


   var scaleline = new ol.control.ScaleLine();
   map.addControl(scaleline);
		       



      var shouldUpdate = true;
      var view = map.getView();
      var updatePermalink = function() {
        if (!shouldUpdate) {
          // do not update the URL when the view was changed in the 'popstate' handler
          shouldUpdate = true;
          return;
        }
        var center = view.getCenter();

        // save visible layers
        var active_layer_names=[];
        map.getLayers().forEach(function(lg){
            lg.getLayers().forEach(function(l){
                var props = l.getProperties();
                if (props.visible) {
                    active_layer_names.push(props.title);
                }
            });
        })
        var active_layer_string = JSON.stringify(active_layer_names);
        var hash = '#map=' +
            view.getZoom() + '/' +
            Math.round(center[0] * 100) / 100 + '/' +
            Math.round(center[1] * 100) / 100 + '/' +
            view.getRotation()+'/'+
            encodeURI(active_layer_string);

        var state = {
          zoom: view.getZoom(),
          center: view.getCenter(),
          rotation: view.getRotation(),
          active_layers: active_layer_names
        };
        window.history.pushState(state, 'map', hash);
      };

      map.on('moveend', updatePermalink);
        all_base_layers.forEach(function(l) {
            l.on('change:visible',updatePermalink);
        });
        all_overlay_layers.forEach(function(l) {
            l.on('change:visible',updatePermalink);
        });

      // restore the view state when navigating through the history, see
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
      window.addEventListener('popstate', function(event) {
        if (event.state === null) {
          return;
        }
        map.getView().setCenter(event.state.center);
        map.getView().setZoom(event.state.zoom);
        map.getView().setRotation(event.state.rotation);
        // TODO - restore active layers
        shouldUpdate = false;
      });




    // http://openlayers.org/en/latest/examples/popup.html?q=popup		       
    var container = document.getElementById('popup');
    var content = document.getElementById('popup-content');
    var closer = document.getElementById('popup-closer');
    var overlay = new ol.Overlay(/** @type {olx.OverlayOptions} */ ({
	element: container,
	autoPan: true,
	autoPanAnimation: {
	    duration: 250
	}
    }));
    map.addOverlay(overlay);
    closer.onclick = function() {
	overlay.setPosition(undefined);
	closer.blur();
	return false;
    };

    function query_osm_data(evt) {
	var coordinate = evt.coordinate;
	var crd4326 = ol.proj.transform(coordinate, 'EPSG:3857', 'EPSG:4326');
	var hdms = ol.coordinate.toStringXY(crd4326,4);


	message = '<b>Data from Open Street Map at '+hdms+'</b><hr>';
	content.innerHTML = message + "<br>...loading...</br>";
        $.get('/map_data?q='+crd4326[0]+','+crd4326[1],function(data) { $("#popup-content").html(message + data)});
	overlay.setPosition(coordinate);
    }
    // If someone clicked on an overlay, they want information on the overlay,
    // so moving this to the selectInteraction instead.
    // map.on('singleclick', query_osm_data);

   // interesting select examples
   // https://openlayersbook.github.io/ch08-interacting-with-your-map/example-02.html
   var debug_select='';

		       var selectEuropa = new ol.style.Style({
		       stroke: new ol.style.Stroke({
		       color: '#ff0000',
		       width: 2
		       })
		       });
		       

   var selectInteraction = new ol.interaction.Select({
       /*
       layers: function (layer) {
               debug_select=layer;
	       return layer.get('id') == 'europa';
       },
       style: [selectEuropa]
       */
   });
   map.getInteractions().extend([selectInteraction]);
   selectInteraction.on('select', function(e) {
      // document.getElementById('status').innerHTML = '&nbsp;
      var selected_features = e.target.getFeatures().getArray();
      if (selected_features.length == 1) {
		   var selected_feature = selected_features[0];
		   debug_select = selected_feature;
		   overlay.setPosition(selected_feature.getGeometry().getCoordinates());
		   var features = selected_feature.getProperties().features;
		   if (features) { 
		       var popup_text = "<b>"+features.length+" license plates seen in this cluster</b>";
		       features.forEach(function(d) {
		         data = d.getProperties().data;
			 popup_text += "<br>"+data['red_VRM']+" at "+data['red_Timestamp'];;
		       });
		       $("#popup-content").html(popup_text)
		   }
      }
      if (selected_features.length == 0) {
      	 query_osm_data(e.mapBrowserEvent);
      }
   });
   var selectedFeatures = selectInteraction.getFeatures();

// http://openlayers.org/en/v3.2.0/examples/box-selection.js
// a DragBox interaction used to select features by drawing boxes

var dragBox = new ol.interaction.DragBox({
    condition: ol.events.condition.platformModifierKeyOnly
});

map.addInteraction(dragBox);

var infoBox = document.getElementById('popup-content');

dragBox.on('boxend', function() {
    // features that intersect the box are added to the collection of
    // selected features, and their names are displayed in the "info"
    // div
    var info = [];
    var extent = dragBox.getGeometry().getExtent();
    vectorSource.forEachFeatureIntersectingExtent(extent, function(feature) {
	selectedFeatures.push(feature);
	info.push(feature.get('name'));
    });
    if (info.length > 0) {
	infoBox.innerHTML = info.join(', ');
    }
});

// clear selection when drawing a new box and when clicking on the map
dragBox.on('boxstart', function() {
    selectedFeatures.clear();
    infoBox.innerHTML = '&nbsp;';
});
map.on('click', function() {
    selectedFeatures.clear();
    infoBox.innerHTML = '&nbsp;';
});



      </script>
</body>
</html>
